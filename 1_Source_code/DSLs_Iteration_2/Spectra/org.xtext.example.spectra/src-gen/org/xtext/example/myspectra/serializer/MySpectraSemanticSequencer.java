/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.myspectra.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.myspectra.services.MySpectraGrammarAccess;
import spectra.BinaryRegExp;
import spectra.BooleanTerm;
import spectra.CompRegExp;
import spectra.Constant;
import spectra.Counter;
import spectra.Decl;
import spectra.Define;
import spectra.DefineArray;
import spectra.DefineDecl;
import spectra.DefineRegExp;
import spectra.DefineRegExpDecl;
import spectra.DomainVarDecl;
import spectra.EXGar;
import spectra.Import;
import spectra.LTLAsm;
import spectra.LTLGar;
import spectra.Model;
import spectra.Monitor;
import spectra.Pattern;
import spectra.PatternParam;
import spectra.PatternParamList;
import spectra.Predicate;
import spectra.PredicateOrPatternReferrable;
import spectra.QuantifierExpr;
import spectra.Referrable;
import spectra.RegExp;
import spectra.SizeDefineDecl;
import spectra.SpectraPackage;
import spectra.Subrange;
import spectra.TemporalAdditiveExpr;
import spectra.TemporalAndExpr;
import spectra.TemporalBinaryExpr;
import spectra.TemporalExpression;
import spectra.TemporalIffExpr;
import spectra.TemporalImpExpr;
import spectra.TemporalInExpr;
import spectra.TemporalMultiplicativeExpr;
import spectra.TemporalOrExpr;
import spectra.TemporalPrimaryExpr;
import spectra.TemporalRelationalExpr;
import spectra.TemporalRemainderExpr;
import spectra.TemporalUnaryExpr;
import spectra.Trigger;
import spectra.TypeConstant;
import spectra.TypeDef;
import spectra.TypedParam;
import spectra.TypedParamList;
import spectra.UnaryRegExp;
import spectra.ValueInRange;
import spectra.Var;
import spectra.VarDecl;
import spectra.VarType;
import spectra.WeightDef;

@SuppressWarnings("all")
public class MySpectraSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MySpectraGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SpectraPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SpectraPackage.BINARY_REG_EXP:
				sequence_BinaryRegExp(context, (BinaryRegExp) semanticObject); 
				return; 
			case SpectraPackage.BOOLEAN_TERM:
				sequence_BooleanTerm(context, (BooleanTerm) semanticObject); 
				return; 
			case SpectraPackage.COMP_REG_EXP:
				sequence_CompRegExp(context, (CompRegExp) semanticObject); 
				return; 
			case SpectraPackage.CONSTANT:
				sequence_Constant(context, (Constant) semanticObject); 
				return; 
			case SpectraPackage.COUNTER:
				sequence_Counter(context, (Counter) semanticObject); 
				return; 
			case SpectraPackage.DECL:
				sequence_Decl_Impl(context, (Decl) semanticObject); 
				return; 
			case SpectraPackage.DEFINE:
				sequence_Define(context, (Define) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_ARRAY:
				sequence_DefineArray(context, (DefineArray) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_DECL:
				sequence_DefineDecl(context, (DefineDecl) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_REG_EXP:
				sequence_DefineRegExp(context, (DefineRegExp) semanticObject); 
				return; 
			case SpectraPackage.DEFINE_REG_EXP_DECL:
				sequence_DefineRegExpDecl(context, (DefineRegExpDecl) semanticObject); 
				return; 
			case SpectraPackage.DOMAIN_VAR_DECL:
				sequence_DomainVarDecl(context, (DomainVarDecl) semanticObject); 
				return; 
			case SpectraPackage.EX_GAR:
				sequence_EXGar(context, (EXGar) semanticObject); 
				return; 
			case SpectraPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case SpectraPackage.LTL_ASM:
				sequence_LTLAsm(context, (LTLAsm) semanticObject); 
				return; 
			case SpectraPackage.LTL_GAR:
				sequence_LTLGar(context, (LTLGar) semanticObject); 
				return; 
			case SpectraPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SpectraPackage.MONITOR:
				sequence_Monitor(context, (Monitor) semanticObject); 
				return; 
			case SpectraPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case SpectraPackage.PATTERN_PARAM:
				sequence_PatternParam(context, (PatternParam) semanticObject); 
				return; 
			case SpectraPackage.PATTERN_PARAM_LIST:
				sequence_PatternParamList(context, (PatternParamList) semanticObject); 
				return; 
			case SpectraPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case SpectraPackage.PREDICATE_OR_PATTERN_REFERRABLE:
				sequence_PredicateOrPatternReferrable_Impl(context, (PredicateOrPatternReferrable) semanticObject); 
				return; 
			case SpectraPackage.QUANTIFIER_EXPR:
				sequence_QuantifierExpr(context, (QuantifierExpr) semanticObject); 
				return; 
			case SpectraPackage.REFERRABLE:
				sequence_Referrable_Impl(context, (Referrable) semanticObject); 
				return; 
			case SpectraPackage.REG_EXP:
				sequence_RegExp_Impl(context, (RegExp) semanticObject); 
				return; 
			case SpectraPackage.SIZE_DEFINE_DECL:
				sequence_SizeDefineDecl(context, (SizeDefineDecl) semanticObject); 
				return; 
			case SpectraPackage.SUBRANGE:
				sequence_Subrange(context, (Subrange) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_ADDITIVE_EXPR:
				sequence_TemporalAdditiveExpr(context, (TemporalAdditiveExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_AND_EXPR:
				sequence_TemporalAndExpr(context, (TemporalAndExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_BINARY_EXPR:
				sequence_TemporalBinaryExpr(context, (TemporalBinaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_EXPRESSION:
				sequence_TemporalExpression_Impl(context, (TemporalExpression) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IFF_EXPR:
				sequence_TemporalIffExpr(context, (TemporalIffExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IMP_EXPR:
				sequence_TemporalImpExpr(context, (TemporalImpExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_IN_EXPR:
				sequence_TemporalInExpr(context, (TemporalInExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_MULTIPLICATIVE_EXPR:
				sequence_TemporalMultiplicativeExpr(context, (TemporalMultiplicativeExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_OR_EXPR:
				sequence_TemporalOrExpr(context, (TemporalOrExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_PRIMARY_EXPR:
				sequence_TemporalPrimaryExpr(context, (TemporalPrimaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_RELATIONAL_EXPR:
				sequence_TemporalRelationalExpr(context, (TemporalRelationalExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_REMAINDER_EXPR:
				sequence_TemporalRemainderExpr(context, (TemporalRemainderExpr) semanticObject); 
				return; 
			case SpectraPackage.TEMPORAL_UNARY_EXPR:
				sequence_TemporalUnaryExpr(context, (TemporalUnaryExpr) semanticObject); 
				return; 
			case SpectraPackage.TRIGGER:
				sequence_Trigger(context, (Trigger) semanticObject); 
				return; 
			case SpectraPackage.TYPE_CONSTANT:
				sequence_TypeConstant(context, (TypeConstant) semanticObject); 
				return; 
			case SpectraPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case SpectraPackage.TYPED_PARAM:
				sequence_TypedParam(context, (TypedParam) semanticObject); 
				return; 
			case SpectraPackage.TYPED_PARAM_LIST:
				sequence_TypedParamList(context, (TypedParamList) semanticObject); 
				return; 
			case SpectraPackage.UNARY_REG_EXP:
				sequence_UnaryRegExp(context, (UnaryRegExp) semanticObject); 
				return; 
			case SpectraPackage.VALUE_IN_RANGE:
				sequence_ValueInRange(context, (ValueInRange) semanticObject); 
				return; 
			case SpectraPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case SpectraPackage.VAR_DECL:
				sequence_VarDecl(context, (VarDecl) semanticObject); 
				return; 
			case SpectraPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			case SpectraPackage.WEIGHT_DEF:
				sequence_WeightDef(context, (WeightDef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     RegExp returns BinaryRegExp
	 *     BinaryRegExp returns BinaryRegExp
	 *
	 * Constraint:
	 *     (
	 *         empty?='empty'? 
	 *         val=EString? 
	 *         op=EString? 
	 *         assrt=BooleanTerm? 
	 *         left=RegExp? 
	 *         right=RegExp?
	 *     )
	 */
	protected void sequence_BinaryRegExp(ISerializationContext context, BinaryRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanTerm returns BooleanTerm
	 *
	 * Constraint:
	 *     relExpr=TemporalExpression?
	 */
	protected void sequence_BooleanTerm(ISerializationContext context, BooleanTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns CompRegExp
	 *     CompRegExp returns CompRegExp
	 *
	 * Constraint:
	 *     (empty?='empty'? val=EString? comp=EString? assrt=BooleanTerm? left=RegExp?)
	 */
	protected void sequence_CompRegExp(ISerializationContext context, CompRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns Constant
	 *     Constant returns Constant
	 *
	 * Constraint:
	 *     (booleanValue=EString? integerValue=EInt?)
	 */
	protected void sequence_Constant(ISerializationContext context, Constant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Counter
	 *     Referrable returns Counter
	 *     Counter returns Counter
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (overflowMethod+=OverflowMethod overflowMethod+=OverflowMethod*)? 
	 *         (underflowMethod+=OverflowMethod underflowMethod+=OverflowMethod*)? 
	 *         range=Subrange? 
	 *         (initial+=TemporalExpression initial+=TemporalExpression*)? 
	 *         (resetPred+=TemporalExpression resetPred+=TemporalExpression*)? 
	 *         (incPred+=TemporalExpression incPred+=TemporalExpression*)? 
	 *         (decPred+=TemporalExpression decPred+=TemporalExpression*)?
	 *     )
	 */
	protected void sequence_Counter(ISerializationContext context, Counter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Decl
	 *     Decl_Impl returns Decl
	 *
	 * Constraint:
	 *     {Decl}
	 */
	protected void sequence_Decl_Impl(ISerializationContext context, Decl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefineArray returns DefineArray
	 *
	 * Constraint:
	 *     ((simpleExprs+=TemporalExpression simpleExprs+=TemporalExpression*)? (innerArrays+=DefineArray innerArrays+=DefineArray*)?)
	 */
	protected void sequence_DefineArray(ISerializationContext context, DefineArray semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DefineDecl
	 *     DefineDecl returns DefineDecl
	 *
	 * Constraint:
	 *     (name=EString simpleExpr=TemporalExpression? (dimensions+=SizeDefineDecl dimensions+=SizeDefineDecl*)? innerArray=DefineArray?)
	 */
	protected void sequence_DefineDecl(ISerializationContext context, DefineDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DefineRegExpDecl
	 *     DefineRegExpDecl returns DefineRegExpDecl
	 *
	 * Constraint:
	 *     (name=EString exp=RegExp?)
	 */
	protected void sequence_DefineRegExpDecl(ISerializationContext context, DefineRegExpDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns DefineRegExp
	 *     DefineRegExp returns DefineRegExp
	 *
	 * Constraint:
	 *     (defineRegsList+=DefineRegExpDecl defineRegsList+=DefineRegExpDecl*)?
	 */
	protected void sequence_DefineRegExp(ISerializationContext context, DefineRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Define
	 *     Define returns Define
	 *
	 * Constraint:
	 *     (defineList+=DefineDecl defineList+=DefineDecl*)?
	 */
	protected void sequence_Define(ISerializationContext context, Define semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns DomainVarDecl
	 *     DomainVarDecl returns DomainVarDecl
	 *
	 * Constraint:
	 *     (name=EString domainType=VarType?)
	 */
	protected void sequence_DomainVarDecl(ISerializationContext context, DomainVarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns EXGar
	 *     EXGar returns EXGar
	 *
	 * Constraint:
	 *     (name=EString regExpPointer=[DefineRegExpDecl|EString]? (elements+=TemporalExpression elements+=TemporalExpression*)? regExp=RegExp?)
	 */
	protected void sequence_EXGar(ISerializationContext context, EXGar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importURI=EString?
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns LTLAsm
	 *     LTLAsm returns LTLAsm
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         safety=EString? 
	 *         stateInv=EString? 
	 *         justice=EString? 
	 *         params=TypedParamList? 
	 *         temporalExpr=TemporalExpression? 
	 *         trig=Trigger?
	 *     )
	 */
	protected void sequence_LTLAsm(ISerializationContext context, LTLAsm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns LTLGar
	 *     LTLGar returns LTLGar
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         safety=EString? 
	 *         stateInv=EString? 
	 *         justice=EString? 
	 *         params=TypedParamList? 
	 *         temporalExpr=TemporalExpression? 
	 *         trig=Trigger?
	 *     )
	 */
	protected void sequence_LTLGar(ISerializationContext context, LTLGar semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=EString (imports+=Import imports+=Import*)? (elements+=Decl elements+=Decl*)?)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Monitor
	 *     Referrable returns Monitor
	 *     Monitor returns Monitor
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         type=VarType? 
	 *         (initial+=TemporalExpression initial+=TemporalExpression*)? 
	 *         (safety+=TemporalExpression safety+=TemporalExpression*)? 
	 *         (stateInv+=TemporalExpression stateInv+=TemporalExpression*)?
	 *     )
	 */
	protected void sequence_Monitor(ISerializationContext context, Monitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternParamList returns PatternParamList
	 *
	 * Constraint:
	 *     (params+=PatternParam params+=PatternParam*)?
	 */
	protected void sequence_PatternParamList(ISerializationContext context, PatternParamList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns PatternParam
	 *     PatternParam returns PatternParam
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_PatternParam(ISerializationContext context, PatternParam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternParamAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Pattern
	 *     PredicateOrPatternReferrable returns Pattern
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         params=PatternParamList? 
	 *         (varDeclList+=VarDecl varDeclList+=VarDecl*)? 
	 *         (initial+=TemporalExpression initial+=TemporalExpression*)? 
	 *         (safety+=TemporalExpression safety+=TemporalExpression*)? 
	 *         (stateInv+=TemporalExpression stateInv+=TemporalExpression*)? 
	 *         (justice+=TemporalExpression justice+=TemporalExpression*)?
	 *     )
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PredicateOrPatternReferrable returns PredicateOrPatternReferrable
	 *     PredicateOrPatternReferrable_Impl returns PredicateOrPatternReferrable
	 *
	 * Constraint:
	 *     {PredicateOrPatternReferrable}
	 */
	protected void sequence_PredicateOrPatternReferrable_Impl(ISerializationContext context, PredicateOrPatternReferrable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Predicate
	 *     PredicateOrPatternReferrable returns Predicate
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (name=EString params=TypedParamList? body=TemporalExpression?)
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns QuantifierExpr
	 *     QuantifierExpr returns QuantifierExpr
	 *
	 * Constraint:
	 *     (operator=EString? domainVar=DomainVarDecl? temporalExpr=TemporalExpression?)
	 */
	protected void sequence_QuantifierExpr(ISerializationContext context, QuantifierExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns Referrable
	 *     Referrable_Impl returns Referrable
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Referrable_Impl(ISerializationContext context, Referrable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferrable_ImplAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns RegExp
	 *     RegExp_Impl returns RegExp
	 *
	 * Constraint:
	 *     (empty?='empty'? val=EString? assrt=BooleanTerm? left=RegExp?)
	 */
	protected void sequence_RegExp_Impl(ISerializationContext context, RegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SizeDefineDecl returns SizeDefineDecl
	 *
	 * Constraint:
	 *     (value=EInt? name=[DefineDecl|EString]? arithExp=TemporalExpression?)
	 */
	protected void sequence_SizeDefineDecl(ISerializationContext context, SizeDefineDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Subrange returns Subrange
	 *
	 * Constraint:
	 *     (from=SizeDefineDecl? to=SizeDefineDecl?)
	 */
	protected void sequence_Subrange(ISerializationContext context, Subrange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalAdditiveExpr
	 *     TemporalAdditiveExpr returns TemporalAdditiveExpr
	 *
	 * Constraint:
	 *     ((operator+=EString operator+=EString*)? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalAdditiveExpr(ISerializationContext context, TemporalAdditiveExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalAndExpr
	 *     TemporalAndExpr returns TemporalAndExpr
	 *
	 * Constraint:
	 *     ((operator+=EString operator+=EString*)? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalAndExpr(ISerializationContext context, TemporalAndExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalBinaryExpr
	 *     TemporalBinaryExpr returns TemporalBinaryExpr
	 *
	 * Constraint:
	 *     ((operator+=EString operator+=EString*)? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalBinaryExpr(ISerializationContext context, TemporalBinaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalExpression
	 *     TemporalExpression_Impl returns TemporalExpression
	 *
	 * Constraint:
	 *     {TemporalExpression}
	 */
	protected void sequence_TemporalExpression_Impl(ISerializationContext context, TemporalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalIffExpr
	 *     TemporalIffExpr returns TemporalIffExpr
	 *
	 * Constraint:
	 *     (operator=EString? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalIffExpr(ISerializationContext context, TemporalIffExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalImpExpr
	 *     TemporalImpExpr returns TemporalImpExpr
	 *
	 * Constraint:
	 *     (operator=EString? left=TemporalExpression? implication=TemporalExpression?)
	 */
	protected void sequence_TemporalImpExpr(ISerializationContext context, TemporalImpExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalInExpr
	 *     TemporalInExpr returns TemporalInExpr
	 *
	 * Constraint:
	 *     (not?='not'? operator=EString? left=TemporalExpression? (values+=ValueInRange values+=ValueInRange*)?)
	 */
	protected void sequence_TemporalInExpr(ISerializationContext context, TemporalInExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalMultiplicativeExpr
	 *     TemporalMultiplicativeExpr returns TemporalMultiplicativeExpr
	 *
	 * Constraint:
	 *     ((operator+=EString operator+=EString*)? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalMultiplicativeExpr(ISerializationContext context, TemporalMultiplicativeExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalOrExpr
	 *     TemporalOrExpr returns TemporalOrExpr
	 *
	 * Constraint:
	 *     ((operator+=EString operator+=EString*)? (elements+=TemporalExpression elements+=TemporalExpression*)?)
	 */
	protected void sequence_TemporalOrExpr(ISerializationContext context, TemporalOrExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalPrimaryExpr
	 *     TemporalPrimaryExpr returns TemporalPrimaryExpr
	 *
	 * Constraint:
	 *     (
	 *         operator=EString? 
	 *         predPatt=[PredicateOrPatternReferrable|EString]? 
	 *         pointer=[Referrable|EString]? 
	 *         regexpPointer=[DefineRegExpDecl|EString]? 
	 *         (predPattParams+=TemporalExpression predPattParams+=TemporalExpression*)? 
	 *         tpe=TemporalExpression? 
	 *         (index+=TemporalExpression index+=TemporalExpression*)? 
	 *         temporalExpression=TemporalExpression? 
	 *         regexp=RegExp?
	 *     )
	 */
	protected void sequence_TemporalPrimaryExpr(ISerializationContext context, TemporalPrimaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalRelationalExpr
	 *     TemporalRelationalExpr returns TemporalRelationalExpr
	 *
	 * Constraint:
	 *     (operator=EString? left=TemporalExpression? right=TemporalExpression?)
	 */
	protected void sequence_TemporalRelationalExpr(ISerializationContext context, TemporalRelationalExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalRemainderExpr
	 *     TemporalRemainderExpr returns TemporalRemainderExpr
	 *
	 * Constraint:
	 *     (operator=EString? left=TemporalExpression? right=TemporalExpression?)
	 */
	protected void sequence_TemporalRemainderExpr(ISerializationContext context, TemporalRemainderExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TemporalExpression returns TemporalUnaryExpr
	 *     TemporalUnaryExpr returns TemporalUnaryExpr
	 *
	 * Constraint:
	 *     (kinds=EString? tue=TemporalExpression?)
	 */
	protected void sequence_TemporalUnaryExpr(ISerializationContext context, TemporalUnaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Trigger returns Trigger
	 *
	 * Constraint:
	 *     (initPointer=[DefineRegExpDecl|EString]? effectPointer=[DefineRegExpDecl|EString]? initRegExp=RegExp? effectRegExp=RegExp?)
	 */
	protected void sequence_Trigger(ISerializationContext context, Trigger semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns TypeConstant
	 *     TypeConstant returns TypeConstant
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_TypeConstant(ISerializationContext context, TypeConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SpectraPackage.Literals.REFERRABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeConstantAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=EString type=VarType?)
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypedParamList returns TypedParamList
	 *
	 * Constraint:
	 *     (params+=TypedParam params+=TypedParam*)?
	 */
	protected void sequence_TypedParamList(ISerializationContext context, TypedParamList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns TypedParam
	 *     TypedParam returns TypedParam
	 *
	 * Constraint:
	 *     (name=EString type=VarType?)
	 */
	protected void sequence_TypedParam(ISerializationContext context, TypedParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegExp returns UnaryRegExp
	 *     UnaryRegExp returns UnaryRegExp
	 *
	 * Constraint:
	 *     (
	 *         empty?='empty'? 
	 *         kleened?='kleened'? 
	 *         questionMark?='questionMark'? 
	 *         plus?='plus'? 
	 *         haveExactRepetition?='haveExactRepetition'? 
	 *         haveAtLeast?='haveAtLeast'? 
	 *         haveRange?='haveRange'? 
	 *         val=EString? 
	 *         exactRepetition=EInt? 
	 *         atLeast=EInt? 
	 *         from=EInt? 
	 *         to=EInt? 
	 *         fromDefine=[DefineDecl|EString]? 
	 *         toDefine=[DefineDecl|EString]? 
	 *         assrt=BooleanTerm? 
	 *         left=RegExp?
	 *     )
	 */
	protected void sequence_UnaryRegExp(ISerializationContext context, UnaryRegExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueInRange returns ValueInRange
	 *
	 * Constraint:
	 *     (
	 *         multi?='multi'? 
	 *         int=EInt? 
	 *         from=EInt? 
	 *         to=EInt? 
	 *         booleanValue=EString? 
	 *         const=[TypeConstant|EString]?
	 *     )
	 */
	protected void sequence_ValueInRange(ISerializationContext context, ValueInRange semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Referrable returns VarDecl
	 *     VarDecl returns VarDecl
	 *
	 * Constraint:
	 *     (name=EString type=VarType?)
	 */
	protected void sequence_VarDecl(ISerializationContext context, VarDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         type=[TypeDef|EString]? 
	 *         subr=Subrange? 
	 *         (const+=TypeConstant const+=TypeConstant*)? 
	 *         (dimensions+=SizeDefineDecl dimensions+=SizeDefineDecl*)?
	 *     )
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns Var
	 *     Var returns Var
	 *
	 * Constraint:
	 *     (kind=VarOwner? var=VarDecl?)
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Decl returns WeightDef
	 *     WeightDef returns WeightDef
	 *
	 * Constraint:
	 *     (name=EString negative=EString? value=EInt? definition=TemporalExpression?)
	 */
	protected void sequence_WeightDef(ISerializationContext context, WeightDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
