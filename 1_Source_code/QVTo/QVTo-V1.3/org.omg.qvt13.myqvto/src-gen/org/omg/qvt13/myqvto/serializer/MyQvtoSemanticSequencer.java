/*
 * generated by Xtext 2.25.0
 */
package org.omg.qvt13.myqvto.serializer;

import EMOF.EMOFPackage;
import QVTOperational.AccessDecl;
import QVTOperational.AccessUsage;
import QVTOperational.ClassifierExtension;
import QVTOperational.ClassifierFeature;
import QVTOperational.ClassifierFeatureList;
import QVTOperational.ClassifierGO;
import QVTOperational.ClassifierHeader;
import QVTOperational.ClassifierInfo;
import QVTOperational.CompleteSignature;
import QVTOperational.ComplexType;
import QVTOperational.Constructor;
import QVTOperational.ConstructorHeader;
import QVTOperational.ContextualProperty;
import QVTOperational.Declarator;
import QVTOperational.DeclaratorList;
import QVTOperational.EntryHeader;
import QVTOperational.EntryOperation;
import QVTOperational.EnumerationGO;
import QVTOperational.EnumerationHeader;
import QVTOperational.ExpressionBlock;
import QVTOperational.ExpressionGO;
import QVTOperational.ExpressionList;
import QVTOperational.ExpressionSemiList;
import QVTOperational.ExtendsUsage;
import QVTOperational.FeatureQualifier;
import QVTOperational.Helper;
import QVTOperational.HelperHeader;
import QVTOperational.HelperInfo;
import QVTOperational.InitPart;
import QVTOperational.Library;
import QVTOperational.LibraryHeader;
import QVTOperational.MappingBody;
import QVTOperational.MappingExtension;
import QVTOperational.MappingExtra;
import QVTOperational.MappingFullHeader;
import QVTOperational.MappingHeader;
import QVTOperational.MappingOperation;
import QVTOperational.MappingRefinement;
import QVTOperational.MetaModelElement;
import QVTOperational.MetaModelGO;
import QVTOperational.MetaModelHeader;
import QVTOperational.ModelType;
import QVTOperational.ModuleImport;
import QVTOperational.ModuleRefGO;
import QVTOperational.ModuleUsageGO;
import QVTOperational.Multiplicity;
import QVTOperational.OperationalTransformation;
import QVTOperational.OppositeProperty;
import QVTOperational.PackageRefGO;
import QVTOperational.ParamList;
import QVTOperational.PopulationSection;
import QVTOperational.QVTOperationalPackage;
import QVTOperational.ScopedIdentifier;
import QVTOperational.ScopedIdentifierList;
import QVTOperational.SimpleSignature;
import QVTOperational.StereotypeQualifier;
import QVTOperational.TagGO;
import QVTOperational.TopLevelGO;
import QVTOperational.TransformationHeader;
import QVTOperational.TransformationUsageRefine;
import QVTOperational.TypeDef;
import QVTOperational.TypeReference;
import QVTOperational.TypeSpec;
import QVTOperational.UnitRefGO;
import QVTOperational.VarParameter;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.omg.qvt13.myqvto.services.MyQvtoGrammarAccess;

@SuppressWarnings("all")
public class MyQvtoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyQvtoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QVTOperationalPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QVTOperationalPackage.ACCESS_DECL:
				sequence_AccessDecl(context, (AccessDecl) semanticObject); 
				return; 
			case QVTOperationalPackage.ACCESS_USAGE:
				sequence_AccessUsage(context, (AccessUsage) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_EXTENSION:
				sequence_ClassifierExtension(context, (ClassifierExtension) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_FEATURE:
				sequence_ClassifierFeature(context, (ClassifierFeature) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_FEATURE_LIST:
				sequence_ClassifierFeatureList(context, (ClassifierFeatureList) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_GO:
				sequence_ClassifierGO(context, (ClassifierGO) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_HEADER:
				sequence_ClassifierHeader(context, (ClassifierHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.CLASSIFIER_INFO:
				sequence_ClassifierInfo(context, (ClassifierInfo) semanticObject); 
				return; 
			case QVTOperationalPackage.COMPLETE_SIGNATURE:
				sequence_CompleteSignature(context, (CompleteSignature) semanticObject); 
				return; 
			case QVTOperationalPackage.COMPLEX_TYPE:
				sequence_ComplexType(context, (ComplexType) semanticObject); 
				return; 
			case QVTOperationalPackage.CONSTRUCTOR:
				sequence_Constructor(context, (Constructor) semanticObject); 
				return; 
			case QVTOperationalPackage.CONSTRUCTOR_HEADER:
				sequence_ConstructorHeader(context, (ConstructorHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.CONTEXTUAL_PROPERTY:
				sequence_ContextualProperty(context, (ContextualProperty) semanticObject); 
				return; 
			case QVTOperationalPackage.DECLARATOR:
				sequence_Declarator(context, (Declarator) semanticObject); 
				return; 
			case QVTOperationalPackage.DECLARATOR_LIST:
				sequence_DeclaratorList(context, (DeclaratorList) semanticObject); 
				return; 
			case QVTOperationalPackage.ENTRY_HEADER:
				sequence_EntryHeader(context, (EntryHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.ENTRY_OPERATION:
				sequence_EntryOperation(context, (EntryOperation) semanticObject); 
				return; 
			case QVTOperationalPackage.ENUMERATION_GO:
				sequence_EnumerationGO(context, (EnumerationGO) semanticObject); 
				return; 
			case QVTOperationalPackage.ENUMERATION_HEADER:
				sequence_EnumerationHeader(context, (EnumerationHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.EXPRESSION_BLOCK:
				sequence_ExpressionBlock(context, (ExpressionBlock) semanticObject); 
				return; 
			case QVTOperationalPackage.EXPRESSION_GO:
				sequence_ExpressionGO(context, (ExpressionGO) semanticObject); 
				return; 
			case QVTOperationalPackage.EXPRESSION_LIST:
				sequence_ExpressionList(context, (ExpressionList) semanticObject); 
				return; 
			case QVTOperationalPackage.EXPRESSION_SEMI_LIST:
				sequence_ExpressionSemiList(context, (ExpressionSemiList) semanticObject); 
				return; 
			case QVTOperationalPackage.EXTENDS_USAGE:
				sequence_ExtendsUsage(context, (ExtendsUsage) semanticObject); 
				return; 
			case QVTOperationalPackage.FEATURE_QUALIFIER:
				sequence_FeatureQualifier(context, (FeatureQualifier) semanticObject); 
				return; 
			case QVTOperationalPackage.HELPER:
				sequence_Helper(context, (Helper) semanticObject); 
				return; 
			case QVTOperationalPackage.HELPER_HEADER:
				sequence_HelperHeader(context, (HelperHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.HELPER_INFO:
				sequence_HelperInfo(context, (HelperInfo) semanticObject); 
				return; 
			case QVTOperationalPackage.INIT_PART:
				sequence_InitPart(context, (InitPart) semanticObject); 
				return; 
			case QVTOperationalPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case QVTOperationalPackage.LIBRARY_HEADER:
				sequence_LibraryHeader(context, (LibraryHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_BODY:
				sequence_MappingBody(context, (MappingBody) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_EXTENSION:
				sequence_MappingExtension(context, (MappingExtension) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_EXTRA:
				sequence_MappingExtra(context, (MappingExtra) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_FULL_HEADER:
				sequence_MappingFullHeader(context, (MappingFullHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_HEADER:
				sequence_MappingHeader(context, (MappingHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_OPERATION:
				sequence_MappingOperation(context, (MappingOperation) semanticObject); 
				return; 
			case QVTOperationalPackage.MAPPING_REFINEMENT:
				sequence_MappingRefinement(context, (MappingRefinement) semanticObject); 
				return; 
			case QVTOperationalPackage.META_MODEL_ELEMENT:
				sequence_MetaModelElement(context, (MetaModelElement) semanticObject); 
				return; 
			case QVTOperationalPackage.META_MODEL_GO:
				sequence_MetaModelGO(context, (MetaModelGO) semanticObject); 
				return; 
			case QVTOperationalPackage.META_MODEL_HEADER:
				sequence_MetaModelHeader(context, (MetaModelHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.MODEL_TYPE:
				sequence_ModelType(context, (ModelType) semanticObject); 
				return; 
			case QVTOperationalPackage.MODULE_IMPORT:
				sequence_ModuleImport(context, (ModuleImport) semanticObject); 
				return; 
			case QVTOperationalPackage.MODULE_REF_GO:
				sequence_ModuleRefGO(context, (ModuleRefGO) semanticObject); 
				return; 
			case QVTOperationalPackage.MODULE_USAGE_GO:
				sequence_ModuleUsageGO(context, (ModuleUsageGO) semanticObject); 
				return; 
			case QVTOperationalPackage.MULTIPLICITY:
				sequence_Multiplicity(context, (Multiplicity) semanticObject); 
				return; 
			case QVTOperationalPackage.OPERATIONAL_TRANSFORMATION:
				sequence_OperationalTransformation(context, (OperationalTransformation) semanticObject); 
				return; 
			case QVTOperationalPackage.OPPOSITE_PROPERTY:
				sequence_OppositeProperty(context, (OppositeProperty) semanticObject); 
				return; 
			case QVTOperationalPackage.PACKAGE_REF_GO:
				sequence_PackageRefGO(context, (PackageRefGO) semanticObject); 
				return; 
			case QVTOperationalPackage.PARAM_LIST:
				sequence_ParamList(context, (ParamList) semanticObject); 
				return; 
			case QVTOperationalPackage.POPULATION_SECTION:
				sequence_PopulationSection(context, (PopulationSection) semanticObject); 
				return; 
			case QVTOperationalPackage.SCOPED_IDENTIFIER:
				sequence_ScopedIdentifier(context, (ScopedIdentifier) semanticObject); 
				return; 
			case QVTOperationalPackage.SCOPED_IDENTIFIER_LIST:
				sequence_ScopedIdentifierList(context, (ScopedIdentifierList) semanticObject); 
				return; 
			case QVTOperationalPackage.SIMPLE_SIGNATURE:
				sequence_SimpleSignature(context, (SimpleSignature) semanticObject); 
				return; 
			case QVTOperationalPackage.STEREOTYPE_QUALIFIER:
				sequence_StereotypeQualifier(context, (StereotypeQualifier) semanticObject); 
				return; 
			case QVTOperationalPackage.TAG_GO:
				sequence_TagGO(context, (TagGO) semanticObject); 
				return; 
			case QVTOperationalPackage.TOP_LEVEL_GO:
				sequence_TopLevelGO(context, (TopLevelGO) semanticObject); 
				return; 
			case QVTOperationalPackage.TRANSFORMATION_HEADER:
				sequence_TransformationHeader(context, (TransformationHeader) semanticObject); 
				return; 
			case QVTOperationalPackage.TRANSFORMATION_USAGE_REFINE:
				sequence_TransformationUsageRefine(context, (TransformationUsageRefine) semanticObject); 
				return; 
			case QVTOperationalPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case QVTOperationalPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case QVTOperationalPackage.TYPE_SPEC:
				sequence_TypeSpec(context, (TypeSpec) semanticObject); 
				return; 
			case QVTOperationalPackage.UNIT_REF_GO:
				sequence_UnitRefGO(context, (UnitRefGO) semanticObject); 
				return; 
			case QVTOperationalPackage.VAR_PARAMETER:
				sequence_VarParameter(context, (VarParameter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Module returns AccessDecl
	 *     ImperativeOperation returns AccessDecl
	 *     AccessDecl returns AccessDecl
	 *
	 * Constraint:
	 *     access_usage=AccessUsage
	 */
	protected void sequence_AccessDecl(ISerializationContext context, AccessDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.ACCESS_DECL__ACCESS_USAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.ACCESS_DECL__ACCESS_USAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccessDeclAccess().getAccess_usageAccessUsageParserRuleCall_0_0(), semanticObject.getAccess_usage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AccessUsage returns AccessUsage
	 *
	 * Constraint:
	 *     (module_kind=ModuleKind? moduleref_list+=ModuleRefGO moduleref_list+=ModuleRefGO*)
	 */
	protected void sequence_AccessUsage(ISerializationContext context, AccessUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierExtension returns ClassifierExtension
	 *
	 * Constraint:
	 *     scoped_identifier_list=ScopedIdentifierList
	 */
	protected void sequence_ClassifierExtension(ISerializationContext context, ClassifierExtension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.CLASSIFIER_EXTENSION__SCOPED_IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.CLASSIFIER_EXTENSION__SCOPED_IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassifierExtensionAccess().getScoped_identifier_listScopedIdentifierListParserRuleCall_1_0(), semanticObject.getScoped_identifier_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierFeatureList returns ClassifierFeatureList
	 *
	 * Constraint:
	 *     (classifier_feature+=ClassifierFeature classifier_feature+=ClassifierFeature*)
	 */
	protected void sequence_ClassifierFeatureList(ISerializationContext context, ClassifierFeatureList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierFeature returns ClassifierFeature
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             feature_qualifier=FeatureQualifier? 
	 *             declarator=Declarator 
	 *             ((multiplicity=Multiplicity? opposite_property=OppositeProperty?) | complete_signature=CompleteSignature)?
	 *         ) | 
	 *         tag=TagGO
	 *     )
	 */
	protected void sequence_ClassifierFeature(ISerializationContext context, ClassifierFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns ClassifierGO
	 *     ImperativeOperation returns ClassifierGO
	 *     ClassifierGO returns ClassifierGO
	 *
	 * Constraint:
	 *     (classifier_h=ClassifierHeader classifier_feature_list=ClassifierFeatureList?)
	 */
	protected void sequence_ClassifierGO(ISerializationContext context, ClassifierGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierHeader returns ClassifierHeader
	 *
	 * Constraint:
	 *     (classifier_info=ClassifierInfo scoped_identifier=ScopedIdentifier classifier_extension=ClassifierExtension?)
	 */
	protected void sequence_ClassifierHeader(ISerializationContext context, ClassifierHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassifierInfo returns ClassifierInfo
	 *
	 * Constraint:
	 *     qualifier+=GeneralQualifier*
	 */
	protected void sequence_ClassifierInfo(ISerializationContext context, ClassifierInfo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CompleteSignature returns CompleteSignature
	 *
	 * Constraint:
	 *     (simple_signature=SimpleSignature param_list=ParamList?)
	 */
	protected void sequence_CompleteSignature(ISerializationContext context, CompleteSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ComplexType returns ComplexType
	 *
	 * Constraint:
	 *     (
	 *         complex_type_key=ComplexTypeKey | 
	 *         (collection_key=CollectionKey typespec+=TypeSpec) | 
	 *         (typespec+=TypeSpec typespec+=TypeSpec) | 
	 *         declarator_list=DeclaratorList
	 *     )
	 */
	protected void sequence_ComplexType(ISerializationContext context, ComplexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstructorHeader returns ConstructorHeader
	 *
	 * Constraint:
	 *     (qualifier+=GeneralQualifier* scoped_identifier=ScopedIdentifier simple_signature=SimpleSignature)
	 */
	protected void sequence_ConstructorHeader(ISerializationContext context, ConstructorHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Constructor
	 *     ImperativeOperation returns Constructor
	 *     Constructor returns Constructor
	 *
	 * Constraint:
	 *     (constructor_header=ConstructorHeader expression_block=ExpressionBlock?)
	 */
	protected void sequence_Constructor(ISerializationContext context, Constructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns ContextualProperty
	 *     ImperativeOperation returns ContextualProperty
	 *     ContextualProperty returns ContextualProperty
	 *
	 * Constraint:
	 *     (property_key+=PropertyKey+ declarator=Declarator)
	 */
	protected void sequence_ContextualProperty(ISerializationContext context, ContextualProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclaratorList returns DeclaratorList
	 *
	 * Constraint:
	 *     (declarator+=Declarator declarator+=Declarator*)
	 */
	protected void sequence_DeclaratorList(ISerializationContext context, DeclaratorList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declarator returns Declarator
	 *
	 * Constraint:
	 *     ((typespec=TypeSpec init_part=InitPart?) | (scoped_identifier=ScopedIdentifier typespec=TypeSpec init_part=InitPart?))
	 */
	protected void sequence_Declarator(ISerializationContext context, Declarator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryHeader returns EntryHeader
	 *
	 * Constraint:
	 *     simple_signature=SimpleSignature
	 */
	protected void sequence_EntryHeader(ISerializationContext context, EntryHeader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.ENTRY_HEADER__SIMPLE_SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.ENTRY_HEADER__SIMPLE_SIGNATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntryHeaderAccess().getSimple_signatureSimpleSignatureParserRuleCall_1_0(), semanticObject.getSimple_signature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns EntryOperation
	 *     ImperativeOperation returns EntryOperation
	 *     EntryOperation returns EntryOperation
	 *
	 * Constraint:
	 *     (entry_header=EntryHeader expression_block=ExpressionBlock?)
	 */
	protected void sequence_EntryOperation(ISerializationContext context, EntryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationGO returns EnumerationGO
	 *
	 * Constraint:
	 *     (enumeration_h=EnumerationHeader (identifier+=EString identifier+=EString*)?)
	 */
	protected void sequence_EnumerationGO(ISerializationContext context, EnumerationGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumerationHeader returns EnumerationHeader
	 *
	 * Constraint:
	 *     identifier=ID
	 */
	protected void sequence_EnumerationHeader(ISerializationContext context, EnumerationHeader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.ENUMERATION_HEADER__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.ENUMERATION_HEADER__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumerationHeaderAccess().getIdentifierIDTerminalRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionBlock returns ExpressionBlock
	 *
	 * Constraint:
	 *     expression_list=ExpressionList?
	 */
	protected void sequence_ExpressionBlock(ISerializationContext context, ExpressionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionGO returns ExpressionGO
	 *
	 * Constraint:
	 *     dummyContent+=EString*
	 */
	protected void sequence_ExpressionGO(ISerializationContext context, ExpressionGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionList returns ExpressionList
	 *
	 * Constraint:
	 *     expression_semi_list=ExpressionSemiList
	 */
	protected void sequence_ExpressionList(ISerializationContext context, ExpressionList semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.EXPRESSION_LIST__EXPRESSION_SEMI_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.EXPRESSION_LIST__EXPRESSION_SEMI_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionListAccess().getExpression_semi_listExpressionSemiListParserRuleCall_0_0(), semanticObject.getExpression_semi_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionSemiList returns ExpressionSemiList
	 *
	 * Constraint:
	 *     (expression+=ExpressionGO expression+=ExpressionGO*)
	 */
	protected void sequence_ExpressionSemiList(ISerializationContext context, ExpressionSemiList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExtendsUsage returns ExtendsUsage
	 *
	 * Constraint:
	 *     (module_kind=ModuleKind? moduleref_list+=ModuleRefGO moduleref_list+=ModuleRefGO*)
	 */
	protected void sequence_ExtendsUsage(ISerializationContext context, ExtendsUsage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeatureQualifier returns FeatureQualifier
	 *
	 * Constraint:
	 *     (stereotype_qualifier=StereotypeQualifier? feature_key+=FeatureKey*)
	 */
	protected void sequence_FeatureQualifier(ISerializationContext context, FeatureQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HelperHeader returns HelperHeader
	 *
	 * Constraint:
	 *     (helper_info=HelperInfo scope_identifier=ScopedIdentifier complete_signature=CompleteSignature)
	 */
	protected void sequence_HelperHeader(ISerializationContext context, HelperHeader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__HELPER_INFO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__HELPER_INFO));
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__SCOPE_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__SCOPE_IDENTIFIER));
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__COMPLETE_SIGNATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.HELPER_HEADER__COMPLETE_SIGNATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHelperHeaderAccess().getHelper_infoHelperInfoParserRuleCall_0_0(), semanticObject.getHelper_info());
		feeder.accept(grammarAccess.getHelperHeaderAccess().getScope_identifierScopedIdentifierParserRuleCall_1_0(), semanticObject.getScope_identifier());
		feeder.accept(grammarAccess.getHelperHeaderAccess().getComplete_signatureCompleteSignatureParserRuleCall_2_0(), semanticObject.getComplete_signature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     HelperInfo returns HelperInfo
	 *
	 * Constraint:
	 *     (qualifier+=GeneralQualifier* helper_kind=HelperKind)
	 */
	protected void sequence_HelperInfo(ISerializationContext context, HelperInfo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Helper
	 *     ImperativeOperation returns Helper
	 *     Helper returns Helper
	 *
	 * Constraint:
	 *     (helper_header=HelperHeader (expression=ExpressionGO | expression_block=ExpressionBlock)?)
	 */
	protected void sequence_Helper(ISerializationContext context, Helper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitPart returns InitPart
	 *
	 * Constraint:
	 *     ((init_op='=' | init_op=':=' | init_op='::=') expression=ExpressionGO)
	 */
	protected void sequence_InitPart(ISerializationContext context, InitPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LibraryHeader returns LibraryHeader
	 *
	 * Constraint:
	 *     (name=ID library_signature=SimpleSignature? module_usage=ModuleUsageGO?)
	 */
	protected void sequence_LibraryHeader(ISerializationContext context, LibraryHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (library_h=LibraryHeader module_element+=ImperativeOperation*)
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingBody returns MappingBody
	 *
	 * Constraint:
	 *     (
	 *         (initSection+=ExpressionGO initSection+=ExpressionGO*)? 
	 *         population_section=PopulationSection? 
	 *         (endSection+=ExpressionGO endSection+=ExpressionGO*)?
	 *     )
	 */
	protected void sequence_MappingBody(ISerializationContext context, MappingBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingExtension returns MappingExtension
	 *
	 * Constraint:
	 *     (mapping_extension_key=MappingExtensionKey scoped_identifier_list=ScopedIdentifierList)
	 */
	protected void sequence_MappingExtension(ISerializationContext context, MappingExtension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.MAPPING_EXTENSION__MAPPING_EXTENSION_KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.MAPPING_EXTENSION__MAPPING_EXTENSION_KEY));
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.MAPPING_EXTENSION__SCOPED_IDENTIFIER_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.MAPPING_EXTENSION__SCOPED_IDENTIFIER_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingExtensionAccess().getMapping_extension_keyMappingExtensionKeyEnumRuleCall_0_0(), semanticObject.getMapping_extension_key());
		feeder.accept(grammarAccess.getMappingExtensionAccess().getScoped_identifier_listScopedIdentifierListParserRuleCall_1_0(), semanticObject.getScoped_identifier_list());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingExtra returns MappingExtra
	 *
	 * Constraint:
	 *     (mapping_extension=MappingExtension | mapping_refinement=MappingRefinement)
	 */
	protected void sequence_MappingExtra(ISerializationContext context, MappingExtra semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingFullHeader returns MappingFullHeader
	 *
	 * Constraint:
	 *     (mapping_header=MappingHeader when=ExpressionBlock? where=ExpressionBlock?)
	 */
	protected void sequence_MappingFullHeader(ISerializationContext context, MappingFullHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingHeader returns MappingHeader
	 *
	 * Constraint:
	 *     (
	 *         qualifier+=GeneralQualifier* 
	 *         param_direction=DirectionKind? 
	 *         scoped_identifier=ScopedIdentifier 
	 *         complete_signature=CompleteSignature 
	 *         mapping_extra+=MappingExtra*
	 *     )
	 */
	protected void sequence_MappingHeader(ISerializationContext context, MappingHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns MappingOperation
	 *     ImperativeOperation returns MappingOperation
	 *     MappingOperation returns MappingOperation
	 *
	 * Constraint:
	 *     (mapping_full_header=MappingFullHeader mapping_body=MappingBody?)
	 */
	protected void sequence_MappingOperation(ISerializationContext context, MappingOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingRefinement returns MappingRefinement
	 *
	 * Constraint:
	 *     scoped_identifier=ScopedIdentifier
	 */
	protected void sequence_MappingRefinement(ISerializationContext context, MappingRefinement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.MAPPING_REFINEMENT__SCOPED_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.MAPPING_REFINEMENT__SCOPED_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingRefinementAccess().getScoped_identifierScopedIdentifierParserRuleCall_1_0(), semanticObject.getScoped_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaModelElement returns MetaModelElement
	 *
	 * Constraint:
	 *     (classifier=ClassifierGO | enumeration=EnumerationGO | tag=TagGO)
	 */
	protected void sequence_MetaModelElement(ISerializationContext context, MetaModelElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns MetaModelGO
	 *     MetaModelGO returns MetaModelGO
	 *
	 * Constraint:
	 *     (metamodel_h=MetaModelHeader metamodel_element+=MetaModelElement*)
	 */
	protected void sequence_MetaModelGO(ISerializationContext context, MetaModelGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MetaModelHeader returns MetaModelHeader
	 *
	 * Constraint:
	 *     scoped_identifier=ScopedIdentifier
	 */
	protected void sequence_MetaModelHeader(ISerializationContext context, MetaModelHeader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.META_MODEL_HEADER__SCOPED_IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.META_MODEL_HEADER__SCOPED_IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetaModelHeaderAccess().getScoped_identifierScopedIdentifierParserRuleCall_1_0(), semanticObject.getScoped_identifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns ModelType
	 *     ModelType returns ModelType
	 *
	 * Constraint:
	 *     (name=ID compliance_kind=STRING? packageref_list+=PackageRefGO packageref_list+=PackageRefGO* modeltype_where=ExpressionBlock?)
	 */
	protected void sequence_ModelType(ISerializationContext context, ModelType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleImport returns ModuleImport
	 *
	 * Constraint:
	 *     ((unit=UnitRefGO (identifier+=ID identifier+=ID*)?) | unit=UnitRefGO)
	 */
	protected void sequence_ModuleImport(ISerializationContext context, ModuleImport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleRefGO returns ModuleRefGO
	 *
	 * Constraint:
	 *     (scoped_identifier=ScopedIdentifier simple_signature=SimpleSignature?)
	 */
	protected void sequence_ModuleRefGO(ISerializationContext context, ModuleRefGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleUsageGO returns ModuleUsageGO
	 *
	 * Constraint:
	 *     (access_usage=AccessUsage | extends_usage=ExtendsUsage)
	 */
	protected void sequence_ModuleUsageGO(ISerializationContext context, ModuleUsageGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiplicity returns Multiplicity
	 *
	 * Constraint:
	 *     multiplicity_range=MULTIPLICITYRANGE
	 */
	protected void sequence_Multiplicity(ISerializationContext context, Multiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.MULTIPLICITY__MULTIPLICITY_RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.MULTIPLICITY__MULTIPLICITY_RANGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicityAccess().getMultiplicity_rangeMULTIPLICITYRANGETerminalRuleCall_1_0(), semanticObject.getMultiplicity_range());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns OperationalTransformation
	 *     OperationalTransformation returns OperationalTransformation
	 *
	 * Constraint:
	 *     (transformation_h=TransformationHeader module_element+=ImperativeOperation*)
	 */
	protected void sequence_OperationalTransformation(ISerializationContext context, OperationalTransformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OppositeProperty returns OppositeProperty
	 *
	 * Constraint:
	 *     (name=ID multiplicity=Multiplicity?)
	 */
	protected void sequence_OppositeProperty(ISerializationContext context, OppositeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageRefGO returns PackageRefGO
	 *
	 * Constraint:
	 *     ((scoped_identifier=ScopedIdentifier uri=STRING?) | uri=STRING)
	 */
	protected void sequence_PackageRefGO(ISerializationContext context, PackageRefGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParamList returns ParamList
	 *
	 * Constraint:
	 *     (param+=VarParameter param+=VarParameter*)
	 */
	protected void sequence_ParamList(ISerializationContext context, ParamList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PopulationSection returns PopulationSection
	 *
	 * Constraint:
	 *     (expression_list=ExpressionList | expression_block=ExpressionBlock)
	 */
	protected void sequence_PopulationSection(ISerializationContext context, PopulationSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopedIdentifierList returns ScopedIdentifierList
	 *
	 * Constraint:
	 *     (scoped_identifier_list+=ScopedIdentifier scoped_identifier_list+=ScopedIdentifier*)
	 */
	protected void sequence_ScopedIdentifierList(ISerializationContext context, ScopedIdentifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopedIdentifier returns ScopedIdentifier
	 *
	 * Constraint:
	 *     (identifier+=ID identifier+=ID*)
	 */
	protected void sequence_ScopedIdentifier(ISerializationContext context, ScopedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleSignature returns SimpleSignature
	 *
	 * Constraint:
	 *     param_list=ParamList?
	 */
	protected void sequence_SimpleSignature(ISerializationContext context, SimpleSignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StereotypeQualifier returns StereotypeQualifier
	 *
	 * Constraint:
	 *     (identifier+=ID identifier+=ID*)
	 */
	protected void sequence_StereotypeQualifier(ISerializationContext context, StereotypeQualifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns TagGO
	 *     ImperativeOperation returns TagGO
	 *     TagGO returns TagGO
	 *
	 * Constraint:
	 *     (tagid=STRING scoped_identifier=ScopedIdentifier tagvalue=ExpressionGO?)
	 */
	protected void sequence_TagGO(ISerializationContext context, TagGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TopLevelGO returns TopLevelGO
	 *
	 * Constraint:
	 *     (moduleimport+=ModuleImport* unit_element+=Module*)
	 */
	protected void sequence_TopLevelGO(ISerializationContext context, TopLevelGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationHeader returns TransformationHeader
	 *
	 * Constraint:
	 *     (qualifier+=GeneralQualifier* name=ID transformation_signature=SimpleSignature transformation_usage_refine=TransformationUsageRefine?)
	 */
	protected void sequence_TransformationHeader(ISerializationContext context, TransformationHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationUsageRefine returns TransformationUsageRefine
	 *
	 * Constraint:
	 *     (module_usage=ModuleUsageGO | transformation_refine=ModuleRefGO)
	 */
	protected void sequence_TransformationUsageRefine(ISerializationContext context, TransformationUsageRefine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Module returns TypeDef
	 *     ImperativeOperation returns TypeDef
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID typespec=TypeSpec)
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EMOFPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EMOFPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, QVTOperationalPackage.Literals.TYPE_DEF__TYPESPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QVTOperationalPackage.Literals.TYPE_DEF__TYPESPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDefAccess().getTypespecTypeSpecParserRuleCall_3_0(), semanticObject.getTypespec());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     (scoped_identifier=ScopedIdentifier | complex_type=ComplexType)
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeSpec returns TypeSpec
	 *
	 * Constraint:
	 *     (type_reference=TypeReference extent_location=ID?)
	 */
	protected void sequence_TypeSpec(ISerializationContext context, TypeSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnitRefGO returns UnitRefGO
	 *
	 * Constraint:
	 *     (identifier+=ID identifier+=ID*)
	 */
	protected void sequence_UnitRefGO(ISerializationContext context, UnitRefGO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarParameter returns VarParameter
	 *
	 * Constraint:
	 *     (kind=DirectionKind? declarator=Declarator)
	 */
	protected void sequence_VarParameter(ISerializationContext context, VarParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
