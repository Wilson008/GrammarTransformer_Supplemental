// automatically generated by Xtext
grammar org.xtext.example.spectra.Spectra with org.eclipse.xtext.common.Terminals

import "http://smlab.cs.tau.ac.il/syntech/Spectra" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns Model:
	(imports+=Import)*
	('module'|'spec') 
	 name=ID 
	(elements+=Decl)+
	;

Decl returns Decl:
	Var | TypeDef | Define | Predicate | Pattern | Monitor | WeightDef | LTLGar | LTLAsm | EXGar | Counter | DefineRegExp;
	
TemporalExpression returns TemporalExpression:
	QuantifierExpr;
	
RegExp returns RegExp:
 	BinaryRegExp;
	
PredicateOrPatternReferrable returns PredicateOrPatternReferrable:
	Pattern | Predicate;

Referrable returns Referrable:
	VarDecl | TypeConstant | DefineDecl | TypedParam | PatternParam | Monitor | Counter | DefineRegExpDecl | DomainVarDecl;
	
Import returns Import:
	'import' 
		importURI=STRING
	;

WeightDef returns WeightDef:
	'weight' 
	(name=ID ':')? 
	negative=('-')? 
	value=INT
	definition=TemporalInExpr ';'
	;

Var returns Var:
	kind=VarOwner 
	var=VarDecl
	;

TypeDef returns TypeDef:
	'type' 
	name=ID 
		'=' type=VarType ';'
	;

Define returns Define:
	'define' 
		(defineList+=DefineDecl)+
	;

DefineRegExp returns DefineRegExp:
	'regexp' 
		(defineRegsList+=DefineRegExpDecl)+
	;

Counter returns Counter:
	'counter' 
	name=ID 
	('(' range=Subrange ')') 
	'{' 
	  (((initial+=TemporalInExpr) | 
		('reset:' resetPred+=TemporalInExpr) | 
		('inc:' incPred+=TemporalExpression) | 
		('dec:' decPred+=TemporalExpression) | 
		('overflow:' overflowMethod+=OverflowMethod) | 
		('underflow:' underflowMethod+=OverflowMethod)) ';')* 
	'}';

Monitor returns Monitor:
	'monitor' 
	type=VarType 
	name=ID 
	'{' 
	(((('ini' | 'initially')? initial+=TemporalInExpr) |    
      (('G' | 'trans') safety+=TemporalInExpr) |
      (('always' | 'alw') stateInv+=TemporalInExpr)) ';')* 
	'}';

Pattern returns Pattern:
	'pattern' 
	name=ID 
	('(' params=PatternParamList ')')?
	('{' 
		('var' varDeclList+=VarDecl)* 
		(((('ini' | 'initially')? initial+=TemporalInExpr) | 
	      (('G' | 'trans') safety+=TemporalInExpr) |
	      (('always' | 'alw') stateInv+=TemporalInExpr) |  
	      (('GF' | 'alwEv'| 'alwaysEventually') justice+=TemporalInExpr)) ';')+ 
	'}');

Predicate returns Predicate:
	'predicate' 
	name=ID 
		('(' params=TypedParamList ')' | '()')
		( (':' body=TemporalExpression ';') | 
		('{' body=TemporalExpression '}'))
	;

LTLGar returns LTLGar:
	('guarantee' | 'gar') 
	(name=ID ('{' params=TypedParamList '}')? ':')?
	((('ini' | 'initially' | safety=('G' | 'trans') | 
	   stateInv=('always' | 'alw') | 
	   justice=('GF' | 'alwEv'| 'alwaysEventually'))? 
	  (temporalExpr=QuantifierExpr)) | 
	 (trig=Trigger)) 
	';';
	

LTLAsm returns LTLAsm:
	('assumption' | 'asm') 
	(name=ID ('{'  params=TypedParamList '}')? ':')?
	((('ini' | 'initially' | safety=('G' | 'trans') | 
	   stateInv=('always' | 'alw') | 
	   justice=('GF' | 'alwEv'| 'alwaysEventually'))? 
	  (temporalExpr=QuantifierExpr)) | 
	 (trig=Trigger)) 
	';';


EXGar returns EXGar:	
	('guarantee' | 'gar') 
	(name=ID ':')?
		(('GE' elements+=TemporalInExpr (',' elements+=TemporalInExpr)*) | 
		 ('GEF' regExpPointer = [DefineRegExpDecl]) | 
		 ('GEF' regExp = RegExp)) 
    ';';

TypeConstantLiteral:
	ID | INT
	;
	
TemporalInExpr returns TemporalExpression:
	TemporalImpExpr 
	({TemporalInExpr.left=current} 
	 (not?='not')? 
	 operator=('in') 
	 '{'	values+=ValueInRange (',' values+=ValueInRange)* '}')?
	;
	
TemporalImpExpr returns TemporalExpression:
	TemporalIffExpr 
	({TemporalImpExpr.left=current} 
	 operator=('->' | 'implies') 
	 implication=TemporalImpExpr)?
	;

TemporalIffExpr returns TemporalExpression:
	TemporalOrExpr 
	({TemporalIffExpr.elements+=current} 
	 operator=('<->' | 'iff') 
	 elements+=TemporalOrExpr)*
	;

TemporalOrExpr returns TemporalExpression:
	TemporalAndExpr	
	({TemporalOrExpr.elements+=current} 
	 operator+=('|' | 'or' | 'xor') 
	 elements+=TemporalAndExpr)*
	;

TemporalAndExpr returns TemporalExpression:
	TemporalRelationalExpr 
	({TemporalAndExpr.elements+=current} 
	 operator+=('&' | 'and') 
	 elements+=TemporalRelationalExpr)*
	;

TemporalRelationalExpr returns TemporalExpression:
	TemporalRemainderExpr	
	({TemporalRelationalExpr.left=current} 
	 operator=('='|'!='|'<'|'>'|'<='|'>=') 
	 right=TemporalRemainderExpr)?
	;
	
TemporalRemainderExpr returns TemporalExpression:
	TemporalAdditiveExpr 
	({TemporalRemainderExpr.left=current} 
	 operator=('mod' | '%') 
	 right=TemporalAdditiveExpr)?
	;

TemporalAdditiveExpr returns TemporalExpression:
	TemporalMultiplicativeExpr 
	({TemporalAdditiveExpr.elements+=current} 
	 operator+=('+'|'-') 
	 elements+=TemporalMultiplicativeExpr)*
	;

TemporalMultiplicativeExpr returns TemporalExpression:
	TemporalBinaryExpr 
	({TemporalMultiplicativeExpr.elements+=current} 
	 operator+=('*'|'/') 
	 elements+=TemporalBinaryExpr)*
	;

TemporalBinaryExpr returns TemporalExpression:
	TemporalUnaryExpr	
	({TemporalBinaryExpr.elements+=current} 
	 operator+=('S' | 'SINCE' | 'T' | 'TRIGGERED') 
	 elements+=TemporalUnaryExpr)*
	;

TemporalUnaryExpr returns TemporalExpression:
	TemporalPrimaryExpr | {TemporalUnaryExpr} 
  	(kinds=('Y' | 'PREV') tue=TemporalUnaryExpr | 
	kinds=('H' | 'HISTORICALLY') tue=TemporalUnaryExpr | 
	kinds=('O' | 'ONCE') tue=TemporalUnaryExpr);

TemporalPrimaryExpr returns TemporalExpression:
	Constant | '(' QuantifierExpr ')' | {TemporalPrimaryExpr}
	(predPatt=[PredicateOrPatternReferrable] 
	 ('(' predPattParams+=TemporalInExpr (',' predPattParams+=TemporalInExpr)* ')' | '()') | 
	 operator=('-'|'!') tpe=TemporalPrimaryExpr | 
	 pointer=[Referrable]('[' index+=TemporalInExpr ']')* | 
	 operator='next' '(' temporalExpression=TemporalInExpr ')' | 
	 operator='regexp' '(' (regexp=RegExp | regexpPointer=[DefineRegExpDecl]) ')' | 
	 pointer=[Referrable] operator='.all' | 
	 pointer=[Referrable] operator='.any' | 
	 pointer=[Referrable] operator='.prod' | 
	 pointer=[Referrable] operator='.sum' | 
	 pointer=[Referrable] operator='.min' | 
	 pointer=[Referrable] operator='.max')
	;

Constant returns TemporalExpression:
	{Constant} 
		(booleanValue='FALSE' | 
		booleanValue='false' | 
		booleanValue='TRUE' | 
		booleanValue='true' | 
		integerValue=INT)
	;

QuantifierExpr returns TemporalExpression:
	TemporalInExpr | 
	{QuantifierExpr}
	(operator=('forall' | 'exists') 
	 domainVar=DomainVarDecl '.' 
     temporalExpr=(QuantifierExpr))
	;

ValueInRange returns ValueInRange:
	 const=[TypeConstant] | 
	 int=INT | 
	 (from=INT multi?='-' to=INT) | 
	 booleanValue=('TRUE' |'FALSE' | 'true' | 'false')
	 ;

TypeConstant returns TypeConstant:
	name=TypeConstantLiteral
	;

DefineRegExpDecl returns DefineRegExpDecl:
	name=ID 
		':=' exp=RegExp ';'
	;

VarDecl returns VarDecl:
	type=VarType 
	name=ID ';'
	;

DefineDecl returns DefineDecl:
	((name=ID ':=' simpleExpr=TemporalExpression) |
	(name=ID ('[' dimensions+=SizeDefineDecl ']')+ 
	 ':=' innerArray=DefineArray ))
	';';

PatternParam returns PatternParam:
	name=ID
	;

TypedParam returns TypedParam:
	type=VarType 
	name=ID
	;

//declaration of a var from domain for quantifier
DomainVarDecl returns DomainVarDecl:
    name=ID 
		'in' domainType=(VarType)
	;

VarType returns VarType:
	(name='boolean' | 
	'Int' '(' subr=Subrange ')' | 
	'{' const+=TypeConstant (',' const+=TypeConstant)* '}' | 
	type=[TypeDef])
	('[' dimensions+=SizeDefineDecl ']')*
	;

Subrange returns Subrange:
		from=SizeDefineDecl 
		'..' to=SizeDefineDecl
	;

//all the declaration that can determine size of array and range of int
SizeDefineDecl returns SizeDefineDecl:
    value=INT | 
	name=[DefineDecl] | 
	'(' arithExp=TemporalExpression ')'
	;

DefineArray returns DefineArray:
	'{' (simpleExprs+=TemporalExpression (',' simpleExprs+=TemporalExpression)*) '}' | 
	'{' (innerArrays+=DefineArray (',' innerArrays+=DefineArray)*) '}' 
	;

BooleanTerm returns BooleanTerm:
	{BooleanTerm} 
	'[' relExpr=TemporalInExpr ']'
	;

BinaryRegExp returns RegExp:
 	UnaryRegExp 
	({BinaryRegExp.left=current} 
	(op=('&' | '|'))? 
	 right=UnaryRegExp)*;
 
UnaryRegExp returns RegExp:
 	CompRegExp 
	({UnaryRegExp.left=current}
	   ((kleened?='*') | 
 		(questionMark?='?') | 
 		(plus?='+') |
        (haveExactRepetition?='{' exactRepetition=INT '}') | 
        (haveAtLeast?='{' atLeast=INT ',' '}') | 
        (haveRange?='{' (from=INT | fromDefine=[DefineDecl]) ',' (to=INT | toDefine=[DefineDecl]) '}')))?
	;

CompRegExp returns RegExp:
 	PrimaryRegExp | 
	({CompRegExp} 
	 (comp='~') 
	 left=CompRegExp)
	;

enum VarOwner returns VarOwner:
	SYS='output' | SYS='out' | SYS='sysvar' | SYS='sys' |  ENV='input' |  ENV='in' | ENV='envvar' |  ENV='env' | AUX='auxvar' | AUX='aux';

enum OverflowMethod returns OverflowMethod: 
	KEEP='keep' | FALSE='false' | MODULO='modulo';

PatternParamList returns PatternParamList: 
	params+=PatternParam (',' params+=PatternParam)*
	;
		
TypedParamList returns TypedParamList:
	params+=TypedParam (',' params+=TypedParam)*
	;

Trigger returns Trigger:
	{Trigger} 
	'trig'  
	(initPointer=[DefineRegExpDecl] | 
	 initRegExp=RegExp ) '|=>' 
	(effectPointer=[DefineRegExpDecl] | 
	 effectRegExp=RegExp);

PrimaryRegExp returns RegExp:
	'(' RegExp ')' | 
	val=('TRUE' |'FALSE' | 'true' | 'false') | 
	assrt=BooleanTerm | 
	empty?='()'
	;

@Override 
terminal SL_COMMENT:
	('//' | '--') !('\n' | '\r')* ('\r'? '\n')?;